#include <Wire.h>                      //IIC通讯头文件
#include <Adafruit_PWMServoDriver.h> //16路舵机控制板头文件
//以这种方式调用，它使用默认地址0x40。
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();
#define SERVOMIN  680   //这是“最小”高电平占空比计数（在4096中）
#define SERVOMAX  2200   //这是“最大”高电平占空比计数（在4096中）

#define VCC 8  //定义8号IO口为VCC（电源）
#define Trig 9 //定义9号IO口连接Trig
#define Echo 10 //定义10号IO口连接Echo

//前进步态帧数据
char wk[36][8]= {
22,-29,18,-22,28,84,-62,-29,
22,-22,13,-22,25,72,-55,-30,
21,-17,9,-21,24,65,-50,-31,
20,-14,6,-20,24,60,-45,-32,
18,-10,3,-18,25,56,-42,-34,
16,-7,0,-16,26,52,-39,-35,
14,-4,-3,-14,27,49,-36,-37,
12,-2,-5,-12,28,46,-33,-39,
10,1,-8,-10,29,44,-31,-41,
8,3,-10,-8,31,41,-29,-44,
5,6,-12,-5,33,39,-28,-46,
3,8,-14,-3,36,37,-27,-49,
0,10,-16,0,39,35,-26,-52,
-3,12,-18,3,42,34,-25,-56,
-6,14,-20,6,45,32,-24,-60,
-9,17,-21,9,50,31,-24,-65,
-13,18,-22,13,55,30,-25,-72,
-18,20,-22,18,62,29,-28,-84,
-29,22,-20,29,84,28,-29,-62,
-22,22,-18,22,72,25,-30,-55,
-17,21,-17,17,65,24,-31,-50,
-14,20,-14,14,60,24,-32,-45,
-10,18,-12,10,56,25,-34,-42,
-7,16,-10,7,52,26,-35,-39,
-4,14,-8,4,49,27,-37,-36,
-2,12,-6,2,46,28,-39,-33,
1,10,-3,-1,44,29,-41,-31,
3,8,-1,-3,41,31,-44,-29,
6,5,2,-6,39,33,-46,-28,
8,3,4,-8,37,36,-49,-27,
10,0,7,-10,35,39,-52,-26,
12,-3,10,-12,34,42,-56,-25,
14,-6,14,-14,32,45,-60,-24,
17,-9,17,-17,31,50,-65,-24,
18,-13,22,-18,30,55,-72,-25,
20,-18,29,-20,29,62,-84,-28
};
//右转舵机角度数据
char yzd[36][8]= {
22,22,-24,-22,28,28,-24,-29,
22,22,-25,-22,25,28,-22,-30,
21,22,-25,-21,24,28,-21,-31,
20,22,-26,-20,24,28,-21,-32,
18,22,-26,-18,25,28,-20,-34,
16,22,-26,-16,26,28,-20,-35,
14,22,-26,-14,27,28,-19,-37,
12,22,-26,-12,28,28,-19,-39,
10,22,-26,-10,29,28,-19,-41,
8,22,-26,-8,31,28,-19,-44,
5,22,-26,-5,33,28,-19,-46,
3,22,-26,-3,36,28,-20,-49,
0,22,-26,0,39,28,-20,-52,
-3,22,-26,3,42,28,-21,-56,
-6,22,-25,6,45,28,-21,-60,
-9,22,-25,9,50,28,-22,-65,
-13,22,-24,13,55,28,-24,-72,
-18,22,-22,18,62,28,-28,-84,
-29,22,-22,29,84,28,-28,-62,
-22,24,-22,22,72,24,-28,-55,
-17,25,-22,17,65,22,-28,-50,
-14,25,-22,14,60,21,-28,-45,
-10,26,-22,10,56,21,-28,-42,
-7,26,-22,7,52,20,-28,-39,
-4,26,-22,4,49,20,-28,-36,
-2,26,-22,2,46,19,-28,-33,
1,26,-22,-1,44,19,-28,-31,
3,26,-22,-3,41,19,-28,-29,
6,26,-22,-6,39,19,-28,-28,
8,26,-22,-8,37,19,-28,-27,
10,26,-22,-10,35,20,-28,-26,
12,26,-22,-12,34,20,-28,-25,
14,26,-22,-14,32,21,-28,-24,
17,25,-22,-17,31,21,-28,-24,
18,25,-22,-18,30,22,-28,-25,
20,24,-22,-20,29,24,-28,-28
  };
//左转舵机角度数据
char zzd[36][8]= {
22,-29,18,-22,28,84,-62,-28,
24,-22,13,-24,24,72,-55,-28,
25,-17,9,-25,22,65,-50,-28,
25,-14,6,-25,21,60,-45,-28,
26,-10,3,-26,21,56,-42,-28,
26,-7,0,-26,20,52,-39,-28,
26,-4,-3,-26,20,49,-36,-28,
26,-2,-5,-26,19,46,-33,-28,
26,1,-8,-26,19,44,-31,-28,
26,3,-10,-26,19,41,-29,-28,
26,6,-12,-26,19,39,-28,-28,
26,8,-14,-26,19,37,-27,-28,
26,10,-16,-26,20,35,-26,-28,
26,12,-18,-26,20,34,-25,-28,
26,14,-20,-26,21,32,-24,-28,
25,17,-21,-25,21,31,-24,-28,
25,18,-22,-25,22,30,-25,-28,
24,20,-22,-24,24,29,-28,-28,
22,22,-20,-22,28,28,-29,-24,
22,22,-18,-22,28,25,-30,-22,
22,21,-17,-22,28,24,-31,-21,
22,20,-14,-22,28,24,-32,-21,
22,18,-12,-22,28,25,-34,-20,
22,16,-10,-22,28,26,-35,-20,
22,14,-8,-22,28,27,-37,-19,
22,12,-6,-22,28,28,-39,-19,
22,10,-3,-22,28,29,-41,-19,
22,8,-1,-22,28,31,-44,-19,
22,5,2,-22,28,33,-46,-19,
22,3,4,-22,28,36,-49,-20,
22,0,7,-22,28,39,-52,-20,
22,-3,10,-22,28,42,-56,-21,
22,-6,14,-22,28,45,-60,-21,
22,-9,17,-22,28,50,-65,-22,
22,-13,22,-22,28,55,-72,-24,
22,-18,29,-22,28,62,-84,-28
  };
//舵机校准偏角数据
char cal[16]={-6,-14,7,0,0,0,0,0,1,9,-3,3,6,-6,7,-6};
//舵机旋转方向
int8_t rotationDirections[] = {1, -1, 1, 1,
                               1, -1, 1, -1,
                               1, -1, -1, 1,
                               -1, 1, 1, -1
                              };
//balance的姿势                              
char balance[16]= { 
  0,  0,  0,  0,  0,  0,  0,  0, 30, 30,-30,-30, 30, 30,-30,-30};

//关节映射表
byte pins[] = {4, 3, 11, 12,
               5, 2, 13, 10,
               6, 1, 14, 9,
               7, 0, 15, 8
              };
//将角度数据转换成高电平占空比
int S2P(int angle){
  float p=0.0;
  p=(1520/150)*angle+680+760;
  return int(p);
}

void balan(){
  for(byte i=0;i<=15;i++)
    pwm.setPWM(pins[i],0,S2P((int(balance[i])+cal[i])*rotationDirections[i]));
  delay(500);
}
//前进函数，ste为走的步数
void qj(byte ste=1){
  for(int k=0;k<ste;k++)
  {
  //循环一次前进步态
  for(int i=0;i<=35;i++)//一共35帧
  {
    for(int j=0;j<=7;j++)//每帧8个舵机角度
    {      
      Serial.print(int(wk[i][j]));
      //具体舵机角度=步态帧中舵机角度数据*旋转方向+舵机校准偏角+75
      //每次从8号关节舵机开始，执行到16号关节舵机，为一帧
      pwm.setPWM(pins[8+j],0,S2P((int(wk[i][j])+cal[8+j])*rotationDirections[j+8]));
      Serial.print(',');
    }
    delay(10);
    Serial.println();
  }
  }
}

//后退函数，ste为走的步数
void ht(byte ste=1){
  for(int k=0;k<ste;k++)
  {
  //循环一次后退步态
  for(int i=0;i<=35;i++)//一共35帧
  {
    for(int j=0;j<=7;j++)//每帧8个舵机角度
    {      
      Serial.print(int(wk[i][j]));
      //具体舵机角度=步态帧中舵机角度数据*旋转方向+舵机校准偏角+75
      //每次从8号关节舵机开始，执行到16号关节舵机，为一帧
      pwm.setPWM(pins[8+j],0,S2P((int(wk[35-i][j])+cal[8+j])*rotationDirections[j+8]));
      Serial.print(',');
    }
    delay(10);
    Serial.println();
  }
  }
}

//右转函数,ste为走的步数
void yz(byte ste=1){
  for(int k=0;k<ste;k++)
  {
  //循环一次后退步态
  for(int i=0;i<=35;i++)//一共35帧
  {
    for(int j=0;j<=7;j++)//每帧8个舵机角度
    {      
      //具体舵机角度=步态帧中舵机角度数据*旋转方向+舵机校准偏角+75
      //每次从8号关节舵机开始，执行到16号关节舵机，为一帧
      pwm.setPWM(pins[8+j],0,S2P((int(yzd[i][j])+cal[8+j])*rotationDirections[j+8]));
    }
    delay(15);
    Serial.println();
  }
  }
}


//左转函数，ste为走的步数
void zz(byte ste=1){
  for(int k=0;k<ste;k++)
  {
  //循环18次左转步态
  for(int i=0;i<=35;i++)//一共35帧
  {
    for(int j=0;j<=7;j++)//每帧8个舵机角度
    {      
      //具体舵机角度=步态帧中舵机角度数据*旋转方向+舵机校准偏角+75
      //每次从8号关节舵机开始，执行到16号关节舵机，为一帧
      pwm.setPWM(pins[8+j],0,S2P((int(zzd[i][j])+cal[8+j])*rotationDirections[j+8]));
    }
    delay(15);
    Serial.println();
  }
  }
}

//向左方避障
void zb()
{
  zz(18);
  delay(500);//停500毫秒
  yz(18);
  delay(500);//停500毫秒
}

//向右方避障
void yb()
{
  yz(18);
  delay(500);//停500毫秒
  zz(18);
  delay(500);//停500毫秒
}


//测距
int dis(){
  float cm; //定义全局变量cm存储距离
  //发一个10ms的高脉冲去触发TrigPin 
  digitalWrite(Trig, LOW); 
  delayMicroseconds(2); 
  digitalWrite(Trig, HIGH); 
  delayMicroseconds(10); 
  digitalWrite(Trig, LOW); 
  //pulseIn函数可以检测出高低电平脉冲宽度
  cm=pulseIn(Echo,HIGH)/58.0; //算成厘米 
  cm=(int(cm * 100.0))/100.0;//保留两位小数 
  Serial.print(cm); 
  Serial.print("cm"); 
  Serial.println(); 
  //delay(100); 
  return int(cm);
}



int dis_prt=0;
void setup() {
   Serial.begin(57600);//打开串口
   pinMode(VCC,OUTPUT); //初始化引脚模式
   digitalWrite(VCC,HIGH); //给模块上电
   pinMode(Trig, OUTPUT); 
   pinMode(Echo, INPUT); 
   pwm.begin();       //初始化PCA9685
   pwm.setPWMFreq(240);  //设置频率240Hz  
   balan();  //起立
   delay(1000);
}

void loop() {
  //障碍距离保持，或者跟随
  dis_prt=dis();
  Serial.println(dis_prt,DEC);
  if(dis_prt>0&&dis_prt<10)
    ht();
  else if(dis_prt>20&&dis_prt<150)
  qj();
  
  //避障
  /*
  dis_prt=dis();
  Serial.println(dis_prt,DEC);
  if(dis_prt>0&&dis_prt<10)
    ht();
  else if(dis_prt>20||dis_prt<0)
  qj();
  else if(dis_prt>10&&dis_prt<20)
  yb();
  */
}
